{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CloudFormation Stacks for Research Computing","text":""},{"location":"01-introduction/","title":"Introduction","text":"<p>Stacks for setting up AWS resources for research computing.</p> <ul> <li><code>DevBucketStack</code>: bucket</li> <li><code>IAMResources</code>: users, groups, roles, and policies</li> <li><code>NetworkStack</code>: VPC and subnets</li> <li><code>LaunchTemplateStack</code>: launch template for EC2 instances</li> </ul> <p><code>DevBucketStack</code> needs only a single parameter, <code>dev_bucket_name</code>, which is the name of the bucket. The parameter can be specified either in the <code>cdk.json</code> file or on the command line using the <code>--context</code> option (see below)</p> <p>All other stacks require the parameter <code>config_folder</code>, which is the path to the folder containing the configuration files:</p> <ul> <li><code>IAMResources</code> uses <code>user_group.yaml</code>, <code>role_policy.yaml</code>, <code>action_mapping.yaml</code>, <code>assume_role.yaml</code></li> <li><code>NetworkStack</code> uses <code>network.yaml</code></li> <li><code>LaunchTemplateStack</code> uses <code>launch_template.yaml</code></li> </ul> <p>The repo contains two sets of configuration files:</p> <ul> <li><code>configs/local</code>: configuration files for the research team (\"local\").</li> <li><code>configs/collab</code>: configuration files for a collaborator to enable access to the S3 resources shared by the research team.</li> </ul> <p>In the example, the collaborator <code>IAMResources</code> stack needs to be set up first because the local <code>IAMResources</code> stack refers to a role created in the collaborator stack. More on this below.</p> <p>CRITICAL NOTE: The <code>DevBucketStack</code> does not have termination protection enabled! This is because the bucket is used for testing and development and it is not intended to be used in production. If you want to use this stack in production, you should enable termination protection.</p>"},{"location":"02-setup/","title":"Setup","text":"<p>To manually create a virtualenv on MacOS and Linux:</p> <pre><code>python3 -m venv .venv\n</code></pre> <p>After the init process completes and the virtualenv is created, you can use the following step to activate your virtualenv.</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>If you are a Windows platform, you would activate the virtualenv like this:</p> <pre><code>% .venv\\Scripts\\activate.bat\n</code></pre> <p>Once the virtualenv is activated, you can install the required dependencies.</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"03-deployment/","title":"Deployment","text":"<p>First create the collaborator stack. For testing purposes, this can be run in the same account as the local stack.</p> <pre><code>cdk deploy IAMResources-collab --context config_folder=\"configs/collab\" --app \"python3 app_collab.py\"\n</code></pre> <p>Then create the local stack</p> <pre><code>cdk deploy DevBucket\ncdk deploy IAMResources --context config_folder=\"configs/local\"\ncdk deploy Network --context config_folder=\"configs/local\"\ncdk deploy LaunchTemplate --context config_folder=\"configs/local\"\n</code></pre>"},{"location":"04-user_management/","title":"User Management","text":"<p>The AWS best practices says that you should not create access keys for users. Instead, you should use an identity provider (IdP) to federate users to AWS. However, if you need to create access keys for a user, you can do so using the AWS CLI.</p> <p>To create an access key for a user:</p> <pre><code>USER=user1\nCREDENTIALS=/tmp/credentials_${USER}.json\n# permissions needed to run this: `iam:CreateAccessKey`\naws iam create-access-key --user-name ${USER} &gt; ${CREDENTIALS} # this is insecure, but it's just for testing\n</code></pre> <p>To delete all access keys for a user:</p> <pre><code>USER=user1\n# permissions needed to run this: `iam:ListAccessKeys` and `iam:DeleteAccessKey`\naws iam list-access-keys --user-name ${USER} | jq -r '.AccessKeyMetadata[].AccessKeyId' | xargs -I {} aws iam delete-access-key --user-name ${USER} --access-key-id {}\n</code></pre> <p>To create a password for a user:</p> <pre><code>USER=user1\n# permissions needed to run this: `iam:CreateLoginProfile`\naws iam create-login-profile --user-name ${USER} --password password1\n</code></pre> <p>To deactivate a user's password:</p> <pre><code>USER=user1\n# permissions needed to run this: `iam:UpdateLoginProfile`\naws iam update-login-profile --user-name ${USER} --password-reset-required\n</code></pre> <p>To list MFA devices for a user:</p> <pre><code>USER=user1\n# permissions needed to run this: `iam:ListMFADevices`\naws iam list-mfa-devices --user-name ${USER}\n</code></pre>"},{"location":"05-credentials_roles/","title":"Credentials and Roles","text":"<p>To export the access key and secret access key as environment variables:</p> <pre><code>USER=user1\nCREDENTIALS=/tmp/credentials_${USER}.json\nexport AWS_ACCESS_KEY_ID=$(cat ${CREDENTIALS} | jq -j '.AccessKey.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(cat ${CREDENTIALS} | jq -j '.AccessKey.SecretAccessKey')\nunset AWS_SESSION_TOKEN # do this just in case you had previously assumed a role\n\n# verify that the credentials work\naws sts get-caller-identity\n</code></pre> <p>Try out a command to which the user does not have access without assuming a role:</p> <pre><code>aws s3 ls s3://ipdata-dev/folder2/\n</code></pre> <p>To assume a role, e.g., <code>typical_data_scientist</code> that will give access to the S3 bucket (and other resources):</p> <pre><code>ROLE=typical_data_scientist\nACCOUNT_ID=$(aws sts get-caller-identity | jq -r .Account)\n\nROLE_CREDENTIALS=/tmp/credentials_${ROLE}.json # this is insecure, but it's just for testing\n\naws sts assume-role --role-arn arn:aws:iam::${ACCOUNT_ID}:role/${ROLE} --role-session-name ${ROLE} &gt; ${ROLE_CREDENTIALS}\n\n# view the credentials\ncat ${ROLE_CREDENTIALS}\n\n# set environment variables\nexport AWS_ACCESS_KEY_ID=$(cat ${ROLE_CREDENTIALS} | jq -j '.Credentials.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(cat ${ROLE_CREDENTIALS} | jq -j '.Credentials.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(cat ${ROLE_CREDENTIALS} | jq -j '.Credentials.SessionToken')\n\n# time until which the credentials are valid\ncat ${ROLE_CREDENTIALS} | jq -j '.Credentials.Expiration'\n\n# verify that the credentials work\naws sts get-caller-identity\n</code></pre> <p>Now that you have assumed the role, you can run the command that you were not able to run before:</p> <pre><code>date &gt; /tmp/test.txt; aws s3 cp /tmp/test.txt s3://ipdata-dev/folder2/\naws s3 ls s3://ipdata-dev/folder2/\n</code></pre> <p>You still can't do everything, e.g., you can't list the top-level bucket:</p> <pre><code>aws s3 ls s3://ipdata-dev/\n# An error occurred (AccessDenied) when calling the ListObjectsV2 operation: Access Denied\n</code></pre> <p>or list a different prefix:</p> <pre><code>aws s3 ls s3://ipdata-dev/folder1/\n# An error occurred (AccessDenied) when calling the ListObjectsV2 operation: Access Denied\n</code></pre>"},{"location":"06-collaborator_access/","title":"Collaborator access","text":"<pre><code>USER=collaborator_user1\nCREDENTIALS=/tmp/credentials_${USER}.json\n# permissions needed to run this: `iam:CreateAccessKey`\naws iam create-access-key --user-name ${USER} &gt; ${CREDENTIALS} # this is insecure, but it's just for testing\n</code></pre> <pre><code>USER=collaborator_user1\nCREDENTIALS=/tmp/credentials_${USER}.json\nexport AWS_ACCESS_KEY_ID=$(cat ${CREDENTIALS} | jq -j '.AccessKey.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(cat ${CREDENTIALS} | jq -j '.AccessKey.SecretAccessKey')\nunset AWS_SESSION_TOKEN # do this just in case you had previously assumed a role\n\n# verify that the credentials work\naws sts get-caller-identity\n</code></pre> <p>This will fail:</p> <pre><code>aws s3 ls s3://ipdata-dev/collaborator-folder1/\n</code></pre> <p>Need to assume the role first:</p> <pre><code>ROLE=requestor-bucket-ipdata-dev\nACCOUNT_ID=$(aws sts get-caller-identity | jq -r .Account)\n\nROLE_CREDENTIALS=/tmp/credentials_${ROLE}.json # this is insecure, but it's just for testing\n\naws sts assume-role --role-arn arn:aws:iam::${ACCOUNT_ID}:role/${ROLE} --role-session-name ${ROLE} &gt; ${ROLE_CREDENTIALS}\n\ncat ${ROLE_CREDENTIALS}\n\nexport AWS_ACCESS_KEY_ID=$(cat ${ROLE_CREDENTIALS} | jq -j '.Credentials.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(cat ${ROLE_CREDENTIALS} | jq -j '.Credentials.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(cat ${ROLE_CREDENTIALS} | jq -j '.Credentials.SessionToken')\n\n# time until which the credentials are valid\ncat ${ROLE_CREDENTIALS} | jq -j '.Credentials.Expiration'\n\n# verify that the credentials work\naws sts get-caller-identity\n</code></pre> <p>Now this will work:</p> <pre><code>aws s3 ls s3://ipdata-dev/collaborator-folder1/\n</code></pre> <p>But this will not:</p> <pre><code>date &gt; /tmp/test.txt; aws s3 cp /tmp/test.txt s3://ipdata-dev/collaborator-folder1/\n# An error occurred (AccessDenied) when calling the PutObject operation: Access Denied\n</code></pre>"},{"location":"07-ec2_instance/","title":"Launch EC2 instances","text":"<p>First, assume the <code>typical_data_scientist</code> role.</p> <p>Generate a new key pair using the AWS CLI:</p> <pre><code># permissions needed to run this: `ec2:CreateKeyPair`\naws ec2 create-key-pair --key-name MyKeyPair --query 'KeyMaterial' --output text &gt; ~/Desktop/MyKeyPair.pem\n</code></pre> <p>This command will create a new key pair named MyKeyPair and save the private key in a file called MyKeyPair.pem. Make sure to protect the private key file, as it's needed to access your instances.</p> <p>Set the correct permissions for the key pair file:</p> <pre><code>chmod 400 ~/Desktop/MyKeyPair.pem\n</code></pre> <p>Launch the instance</p> <pre><code>VPC_NAME=vpc-dev\nSECURITY_GROUP_NAME=ssh_from_vpn\nLAUNCH_TEMPLATE_NAME=lt-small\n\nLAUNCH_TEMPLATE_ID=$(aws ec2 describe-launch-templates --launch-template-names ${LAUNCH_TEMPLATE_NAME} | jq -r '.LaunchTemplates[0].LaunchTemplateId')\nVPC_ID=$(aws ec2 describe-vpcs --filters Name=tag:Name,Values=${VPC_NAME} | jq -r '.Vpcs[0].VpcId')\nSECURITY_GROUP_ID=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=${VPC_ID} --filters Name=group-name,Values=${SECURITY_GROUP_NAME}| jq -r '.SecurityGroups[0].GroupId')\n\nSUBNET_ID=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} | jq -r 'first(.Subnets[] | select(.AvailabilityZone == \"us-east-1a\" and .MapPublicIpOnLaunch == true) | .SubnetId)')\n\necho $SUBNET_ID\n\nINSTANCE_NAME=ec2-test\n\nINSTANCE_PROFILE_NAME=minimal\n\naws ec2 run-instances --launch-template LaunchTemplateId=${LAUNCH_TEMPLATE_ID} --key-name MyKeyPair --security-group-ids ${SECURITY_GROUP_ID} --subnet-id ${SUBNET_ID} --tag-specifications \"ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_NAME}}]\" --iam-instance-profile Name=${INSTANCE_PROFILE_NAME} # --dry-run\n</code></pre> <p>Get the instance id</p> <pre><code>INSTANCE_ID=$(aws ec2 describe-instances --filters Name=tag:Name,Values=${INSTANCE_NAME} --filters Name=instance-state-name,Values=running | jq -r '.Reservations[0].Instances[0].InstanceId')\necho ${INSTANCE_ID}\n# this will show up as null if the instance is not running (or if it doesn't exist)\n</code></pre> <p>Connect to the instance</p> <pre><code>\n# get the public ip address\nPUBLIC_IP=$(aws ec2 describe-instances --instance-ids ${INSTANCE_ID} | jq -r '.Reservations[0].Instances[0].PublicIpAddress')\necho ${PUBLIC_IP}\n\n# get the status of the instance\naws ec2 describe-instance-status --instance-ids ${INSTANCE_ID}\n\n# connect to the instance once ready\nssh -i ~/Desktop/MyKeyPair.pem ec2-user@${PUBLIC_IP}\n</code></pre> <p>Terminate the instance</p> <pre><code>aws ec2 terminate-instances --instance-ids ${INSTANCE_ID}\n</code></pre>"},{"location":"99-addendum/","title":"Addendum","text":""},{"location":"99-addendum/#useful-commands","title":"Useful commands","text":"<ul> <li><code>cdk ls</code>          list all stacks in the app</li> <li><code>cdk synth</code>       emits the synthesized CloudFormation template</li> <li><code>cdk deploy</code>      deploy this stack to your default AWS account/region</li> <li><code>cdk diff</code>        compare deployed stack with current state</li> <li><code>cdk docs</code>        open CDK documentation</li> </ul>"}]}